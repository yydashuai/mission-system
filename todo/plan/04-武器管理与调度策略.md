# 武器管理与调度策略

## 一、武器管理架构

### 1.1 武器容器化设计

武器系统以容器镜像形式存在，每个武器是一个独立的容器应用，通过标准接口与飞机控制系统通信。

```
武器容器架构：

┌─────────────────────────────────────────┐
│         飞机控制系统容器                 │
│      (aircraft-control)                 │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │   飞行控制模块                   │   │
│  ├─────────────────────────────────┤   │
│  │   任务管理模块                   │   │
│  ├─────────────────────────────────┤   │
│  │   武器接口层                     │   │
│  │   /weapons/                     │   │
│  │   ├── control.sock ←─────────┐  │   │
│  │   ├── status.sock            │  │   │
│  │   └── data.sock              │  │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
              ↑
              │ Unix Socket / gRPC
              │
┌─────────────┴───────────┬───────────────┐
│                         │               │
│  ┌─────────────────┐   │  ┌──────────────────┐
│  │ PL-15 导弹容器  │   │  │ PL-10 导弹容器   │
│  │                 │   │  │                  │
│  │ ┌─────────────┐ │   │  │ ┌──────────────┐ │
│  │ │制导系统     │ │   │  │ │制导系统      │ │
│  │ ├─────────────┤ │   │  │ ├──────────────┤ │
│  │ │目标跟踪     │ │   │  │ │目标跟踪      │ │
│  │ ├─────────────┤ │   │  │ ├──────────────┤ │
│  │ │接口服务     │ │   │  │ │接口服务      │ │
│  │ │gRPC Server  │ │   │  │ │gRPC Server   │ │
│  │ └─────────────┘ │   │  │ └──────────────┘ │
│  └─────────────────┘   │  └──────────────────┘
└────────────────────────┴────────────────────┘
           Shared Volume
```

### 1.2 武器接口标准

所有武器容器必须实现标准的武器接口协议（Weapon Interface Protocol, WIP）：

```protobuf
// weapon_interface.proto

syntax = "proto3";
package weapon;

// 武器服务接口
service WeaponService {
  // 初始化武器系统
  rpc Initialize(InitRequest) returns (InitResponse);

  // 获取武器状态
  rpc GetStatus(StatusRequest) returns (StatusResponse);

  // 锁定目标
  rpc LockTarget(LockRequest) returns (LockResponse);

  // 发射武器
  rpc Launch(LaunchRequest) returns (LaunchResponse);

  // 中止发射
  rpc Abort(AbortRequest) returns (AbortResponse);

  // 自检
  rpc SelfCheck(SelfCheckRequest) returns (SelfCheckResponse);
}

message InitRequest {
  string mount_point = 1;       // 挂载点位置
  int32 quantity = 2;           // 数量
  map<string, string> config = 3; // 配置参数
}

message StatusResponse {
  enum WeaponState {
    INITIALIZING = 0;
    READY = 1;
    LOCKED = 2;
    LAUNCHED = 3;
    FAULT = 4;
  }

  WeaponState state = 1;
  int32 remaining_count = 2;    // 剩余数量
  float temperature = 3;         // 温度
  bool self_check_passed = 4;   // 自检是否通过
  string message = 5;            // 状态消息
}

message LockRequest {
  Target target = 1;
}

message Target {
  double latitude = 1;
  double longitude = 2;
  double altitude = 3;
  string target_type = 4;       // 目标类型
  float velocity = 5;           // 目标速度
}

message LaunchRequest {
  string target_id = 1;
  int32 count = 2;              // 发射数量
}
```

## 二、武器挂载方案

### 2.1 Sidecar注入机制

FlightTask Controller在创建Pod时，自动注入武器Sidecar容器：

```go
// 武器注入流程
func (r *FlightTaskReconciler) injectWeaponSidecars(ctx context.Context, pod *corev1.Pod, task *airforcev1alpha1.FlightTask) error {

    // 1. 遍历任务所需的武器
    for _, weaponLoadout := range task.Spec.WeaponLoadout {

        // 2. 获取武器定义
        weapon := &airforcev1alpha1.Weapon{}
        if err := r.Get(ctx, client.ObjectKey{
            Name:      weaponLoadout.WeaponRef.Name,
            Namespace: "weapons",
        }, weapon); err != nil {
            return fmt.Errorf("获取武器定义失败: %v", err)
        }

        // 3. 检查武器与飞机的兼容性
        aircraftType := task.Spec.AircraftRequirement.Type
        if !contains(weapon.Spec.Compatibility.AircraftTypes, aircraftType) {
            return fmt.Errorf("武器 %s 不兼容飞机型号 %s", weapon.Name, aircraftType)
        }

        // 4. 检查挂载点类型兼容性
        for _, mountPoint := range weaponLoadout.MountPoints {
            mountPointType := getMountPointType(mountPoint)
            if !contains(weapon.Spec.Compatibility.HardpointTypes, mountPointType) {
                return fmt.Errorf("武器 %s 不兼容挂载点类型 %s", weapon.Name, mountPointType)
            }
        }

        // 5. 创建Sidecar容器
        sidecar := corev1.Container{
            Name:  fmt.Sprintf("weapon-%s", weapon.Name),
            Image: fmt.Sprintf("%s:%s", weapon.Spec.Image.Repository, weapon.Spec.Image.Tag),

            // 环境变量
            Env: []corev1.EnvVar{
                {Name: "WEAPON_TYPE", Value: weapon.Spec.WeaponType},
                {Name: "QUANTITY", Value: fmt.Sprintf("%d", weaponLoadout.Quantity)},
                {Name: "MOUNT_POINTS", Value: strings.Join(weaponLoadout.MountPoints, ",")},
                {Name: "AIRCRAFT_TYPE", Value: aircraftType},
            },

            // 卷挂载（共享Unix Socket）
            VolumeMounts: []corev1.VolumeMount{
                {
                    Name:      "weapon-interface",
                    MountPath: "/interface",
                },
                {
                    Name:      "weapon-config",
                    MountPath: "/config",
                },
            },

            // 端口（gRPC服务）
            Ports: []corev1.ContainerPort{
                {
                    Name:          "grpc",
                    ContainerPort: 9001,
                    Protocol:      corev1.ProtocolTCP,
                },
            },

            // 资源限制
            Resources: corev1.ResourceRequirements{
                Requests: corev1.ResourceList{
                    corev1.ResourceCPU:    resource.MustParse("100m"),
                    corev1.ResourceMemory: resource.MustParse("128Mi"),
                },
                Limits: corev1.ResourceList{
                    corev1.ResourceCPU:    resource.MustParse("500m"),
                    corev1.ResourceMemory: resource.MustParse("512Mi"),
                },
            },

            // 健康检查
            LivenessProbe: &corev1.Probe{
                Handler: corev1.Handler{
                    HTTPGet: &corev1.HTTPGetAction{
                        Path: "/healthz",
                        Port: intstr.FromInt(9001),
                    },
                },
                InitialDelaySeconds: 5,
                PeriodSeconds:       10,
            },

            ReadinessProbe: &corev1.Probe{
                Handler: corev1.Handler{
                    Exec: &corev1.ExecAction{
                        Command: []string{"/bin/grpc_health_probe", "-addr=:9001"},
                    },
                },
                InitialDelaySeconds: 3,
                PeriodSeconds:       5,
            },
        }

        // 6. 添加到Pod
        pod.Spec.Containers = append(pod.Spec.Containers, sidecar)
    }

    // 7. 添加Init Container（武器预加载）
    initContainer := corev1.Container{
        Name:  "weapon-preload",
        Image: "registry.mil/utils/weapon-loader:v1.0",
        Command: []string{"/bin/sh", "-c"},
        Args: []string{`
            echo "开始武器系统预加载..."
            # 检查武器镜像
            # 预热武器系统
            # 验证接口
            echo "武器系统预加载完成"
        `},
        VolumeMounts: []corev1.VolumeMount{
            {Name: "weapon-interface", MountPath: "/interface"},
        },
    }
    pod.Spec.InitContainers = append(pod.Spec.InitContainers, initContainer)

    // 8. 添加共享卷
    if pod.Spec.Volumes == nil {
        pod.Spec.Volumes = []corev1.Volume{}
    }
    pod.Spec.Volumes = append(pod.Spec.Volumes,
        corev1.Volume{
            Name: "weapon-interface",
            VolumeSource: corev1.VolumeSource{
                EmptyDir: &corev1.EmptyDirVolumeSource{},
            },
        },
        corev1.Volume{
            Name: "weapon-config",
            VolumeSource: corev1.VolumeSource{
                ConfigMap: &corev1.ConfigMapVolumeSource{
                    LocalObjectReference: corev1.LocalObjectReference{
                        Name: "weapon-configs",
                    },
                },
            },
        },
    )

    return nil
}
```

### 2.2 武器生命周期管理

```
武器生命周期：

创建FlightTask
    ↓
Controller解析WeaponLoadout
    ↓
检查武器兼容性
    ↓
注入Sidecar容器
    ↓
创建Pod
    ↓
Init Container预加载武器
    ↓
主容器和Sidecar同时启动
    ↓
武器系统初始化（Initialize RPC）
    ↓
武器就绪（READY状态）
    ↓
任务执行（锁定、发射）
    ↓
任务完成
    ↓
Pod终止，Sidecar随之清理
```

### 2.3 武器容器示例

```dockerfile
# Dockerfile for PL-15 Missile
FROM registry.mil/base/weapon-base:v1.0

# 安装依赖
RUN apt-get update && apt-get install -y \
    libgrpc++ \
    libprotobuf \
    && rm -rf /var/lib/apt/lists/*

# 复制武器系统二进制文件
COPY bin/pl15-missile /usr/local/bin/
COPY config/pl15-config.yaml /etc/weapon/

# 复制gRPC接口实现
COPY lib/weapon_interface.so /usr/local/lib/

# 设置环境变量
ENV WEAPON_TYPE=pl15
ENV GUIDANCE_MODE=active-radar
ENV MAX_RANGE=200000

# 暴露gRPC端口
EXPOSE 9001

# 启动命令
ENTRYPOINT ["/usr/local/bin/pl15-missile"]
CMD ["--config", "/etc/weapon/pl15-config.yaml", "--port", "9001"]
```

```go
// PL-15武器系统服务实现
package main

import (
    "context"
    "fmt"
    "log"
    "net"

    pb "weapon/proto"
    "google.golang.org/grpc"
)

type PL15WeaponServer struct {
    pb.UnimplementedWeaponServiceServer
    state      pb.StatusResponse_WeaponState
    quantity   int32
    mountPoint string
}

func (s *PL15WeaponServer) Initialize(ctx context.Context, req *pb.InitRequest) (*pb.InitResponse, error) {
    log.Printf("初始化PL-15导弹系统: 挂载点=%s, 数量=%d", req.MountPoint, req.Quantity)

    s.mountPoint = req.MountPoint
    s.quantity = req.Quantity

    // 执行初始化
    if err := s.performInitialization(); err != nil {
        return &pb.InitResponse{Success: false, Message: err.Error()}, nil
    }

    s.state = pb.StatusResponse_READY
    return &pb.InitResponse{Success: true, Message: "初始化成功"}, nil
}

func (s *PL15WeaponServer) GetStatus(ctx context.Context, req *pb.StatusRequest) (*pb.StatusResponse, error) {
    return &pb.StatusResponse{
        State:            s.state,
        RemainingCount:   s.quantity,
        Temperature:      25.5,
        SelfCheckPassed:  true,
        Message:          "系统正常",
    }, nil
}

func (s *PL15WeaponServer) LockTarget(ctx context.Context, req *pb.LockRequest) (*pb.LockResponse, error) {
    log.Printf("锁定目标: lat=%.4f, lon=%.4f, alt=%.1f",
        req.Target.Latitude, req.Target.Longitude, req.Target.Altitude)

    // 执行目标锁定
    if err := s.performTargetLock(req.Target); err != nil {
        return &pb.LockResponse{Success: false, Message: err.Error()}, nil
    }

    s.state = pb.StatusResponse_LOCKED
    return &pb.LockResponse{Success: true, Message: "目标已锁定"}, nil
}

func (s *PL15WeaponServer) Launch(ctx context.Context, req *pb.LaunchRequest) (*pb.LaunchResponse, error) {
    log.Printf("发射导弹: 目标=%s, 数量=%d", req.TargetId, req.Count)

    if s.quantity < req.Count {
        return &pb.LaunchResponse{
            Success: false,
            Message: fmt.Sprintf("导弹数量不足: 需要%d枚，剩余%d枚", req.Count, s.quantity),
        }, nil
    }

    // 执行发射
    if err := s.performLaunch(req); err != nil {
        return &pb.LaunchResponse{Success: false, Message: err.Error()}, nil
    }

    s.quantity -= req.Count
    s.state = pb.StatusResponse_LAUNCHED

    return &pb.LaunchResponse{
        Success: true,
        Message: fmt.Sprintf("成功发射%d枚导弹", req.Count),
    }, nil
}

func main() {
    // 启动gRPC服务器
    lis, err := net.Listen("tcp", ":9001")
    if err != nil {
        log.Fatalf("监听失败: %v", err)
    }

    grpcServer := grpc.NewServer()
    pb.RegisterWeaponServiceServer(grpcServer, &PL15WeaponServer{
        state: pb.StatusResponse_INITIALIZING,
    })

    log.Println("PL-15武器系统服务启动，监听端口 :9001")
    if err := grpcServer.Serve(lis); err != nil {
        log.Fatalf("服务启动失败: %v", err)
    }
}
```

## 三、调度策略设计

### 3.1 自定义调度器架构

```
┌──────────────────────────────────────────────────────┐
│          Kubernetes Scheduler Framework              │
│                                                      │
│  ┌────────────────────────────────────────────┐    │
│  │         PreFilter Plugins                   │    │
│  │  - NodeResourcesFit (CPU, Memory)          │    │
│  │  - AircraftAvailability (自定义)            │    │
│  └────────────────────────────────────────────┘    │
│                      ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │          Filter Plugins                     │    │
│  │  - NodeAffinity                            │    │
│  │  - TaintToleration                         │    │
│  │  - AircraftCapability (自定义)              │    │
│  │  - FuelCheck (自定义)                       │    │
│  │  - WeaponCompatibility (自定义)             │    │
│  └────────────────────────────────────────────┘    │
│                      ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │          Score Plugins                      │    │
│  │  - NodeResourcesBalancedAllocation         │    │
│  │  - FuelLevelScore (自定义)                  │    │
│  │  - LocationScore (自定义)                   │    │
│  │  - MaintenanceScore (自定义)                │    │
│  └────────────────────────────────────────────┘    │
│                      ↓                              │
│  ┌────────────────────────────────────────────┐    │
│  │         Bind Plugin                         │    │
│  │  - DefaultBinder                           │    │
│  └────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

### 3.2 自定义调度插件实现

```go
package scheduler

import (
    "context"
    "fmt"
    "strconv"

    v1 "k8s.io/api/core/v1"
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/kubernetes/pkg/scheduler/framework"
)

// AircraftCapabilityPlugin 飞机能力检查插件
type AircraftCapabilityPlugin struct {
    handle framework.Handle
}

func (p *AircraftCapabilityPlugin) Name() string {
    return "AircraftCapability"
}

// Filter 实现过滤逻辑
func (p *AircraftCapabilityPlugin) Filter(
    ctx context.Context,
    state *framework.CycleState,
    pod *v1.Pod,
    nodeInfo *framework.NodeInfo,
) *framework.Status {

    node := nodeInfo.Node()
    if node == nil {
        return framework.NewStatus(framework.Error, "node not found")
    }

    // 1. 检查飞机型号匹配
    requiredType := pod.Spec.NodeSelector["aircraft.type"]
    if requiredType != "" && node.Labels["aircraft.mil/type"] != requiredType {
        return framework.NewStatus(framework.Unschedulable,
            fmt.Sprintf("飞机型号不匹配: 需要%s", requiredType))
    }

    // 2. 检查飞机状态
    aircraftStatus := node.Labels["aircraft.mil/status"]
    if aircraftStatus != "ready" {
        return framework.NewStatus(framework.Unschedulable,
            fmt.Sprintf("飞机状态不就绪: %s", aircraftStatus))
    }

    // 3. 检查是否正在执行任务（Node上是否已有Pod）
    if len(nodeInfo.Pods) > 0 {
        return framework.NewStatus(framework.Unschedulable,
            "飞机正在执行其他任务")
    }

    // 4. 检查燃料是否充足
    requiredFuel := pod.Annotations["required-fuel-level"]
    if requiredFuel != "" {
        currentFuel, _ := strconv.Atoi(node.Labels["aircraft.mil/fuel.level"])
        required, _ := strconv.Atoi(requiredFuel)
        if currentFuel < required {
            return framework.NewStatus(framework.Unschedulable,
                fmt.Sprintf("燃料不足: 当前%d%%, 需要%d%%", currentFuel, required))
        }
    }

    // 5. 检查挂载点数量
    requiredHardpoints := pod.Annotations["required-hardpoints"]
    if requiredHardpoints != "" {
        available, _ := strconv.Atoi(node.Labels["aircraft.mil/hardpoint.available"])
        required, _ := strconv.Atoi(requiredHardpoints)
        if available < required {
            return framework.NewStatus(framework.Unschedulable,
                fmt.Sprintf("挂载点不足: 可用%d个，需要%d个", available, required))
        }
    }

    // 6. 检查武器兼容性
    requiredWeapons := pod.Labels["required-weapons"]
    if requiredWeapons != "" {
        compatibleWeapons := node.Annotations["aircraft.mil/compatible-weapons"]
        if !isWeaponCompatible(requiredWeapons, compatibleWeapons) {
            return framework.NewStatus(framework.Unschedulable,
                fmt.Sprintf("武器不兼容: 需要%s", requiredWeapons))
        }
    }

    return framework.NewStatus(framework.Success, "")
}

// FuelLevelScorePlugin 燃料评分插件
type FuelLevelScorePlugin struct {
    handle framework.Handle
}

func (p *FuelLevelScorePlugin) Name() string {
    return "FuelLevelScore"
}

// Score 实现评分逻辑（0-100分）
func (p *FuelLevelScorePlugin) Score(
    ctx context.Context,
    state *framework.CycleState,
    pod *v1.Pod,
    nodeName string,
) (int64, *framework.Status) {

    nodeInfo, err := p.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)
    if err != nil {
        return 0, framework.NewStatus(framework.Error, fmt.Sprintf("获取节点失败: %v", err))
    }

    node := nodeInfo.Node()

    // 根据燃料等级评分
    fuelLevel, _ := strconv.Atoi(node.Labels["aircraft.mil/fuel.level"])

    // 燃料越高，分数越高（线性映射到0-100）
    score := int64(fuelLevel)

    return score, framework.NewStatus(framework.Success, "")
}

// LocationScorePlugin 位置评分插件
type LocationScorePlugin struct {
    handle framework.Handle
}

func (p *LocationScorePlugin) Name() string {
    return "LocationScore"
}

func (p *LocationScorePlugin) Score(
    ctx context.Context,
    state *framework.CycleState,
    pod *v1.Pod,
    nodeName string,
) (int64, *framework.Status) {

    nodeInfo, err := p.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)
    if err != nil {
        return 0, framework.NewStatus(framework.Error, fmt.Sprintf("获取节点失败: %v", err))
    }

    node := nodeInfo.Node()

    // 获取任务的目标区域
    targetZone := pod.Annotations["target-zone"]
    if targetZone == "" {
        return 50, framework.NewStatus(framework.Success, "")  // 默认中等分数
    }

    // 获取飞机的当前位置
    aircraftZone := node.Labels["aircraft.mil/location.zone"]

    // 位置匹配度评分
    var score int64
    if aircraftZone == targetZone {
        score = 100  // 完美匹配
    } else if isAdjacentZone(aircraftZone, targetZone) {
        score = 70   // 相邻区域
    } else {
        score = 30   // 较远区域
    }

    return score, framework.NewStatus(framework.Success, "")
}

// MaintenanceScorePlugin 维护状态评分插件
type MaintenanceScorePlugin struct {
    handle framework.Handle
}

func (p *MaintenanceScorePlugin) Score(
    ctx context.Context,
    state *framework.CycleState,
    pod *v1.Pod,
    nodeName string,
) (int64, *framework.Status) {

    nodeInfo, err := p.handle.SnapshotSharedLister().NodeInfos().Get(nodeName)
    if err != nil {
        return 0, framework.NewStatus(framework.Error, fmt.Sprintf("获取节点失败: %v", err))
    }

    node := nodeInfo.Node()

    // 解析维护信息
    maintenanceInfo := node.Annotations["aircraft.mil/maintenance"]
    daysUntilMaintenance := parseDaysUntilMaintenance(maintenanceInfo)

    // 距离维护时间越远，分数越高
    var score int64
    if daysUntilMaintenance > 30 {
        score = 100
    } else if daysUntilMaintenance > 15 {
        score = 70
    } else if daysUntilMaintenance > 7 {
        score = 40
    } else {
        score = 20  // 即将维护，不建议使用
    }

    return score, framework.NewStatus(framework.Success, "")
}
```

### 3.3 调度器配置

```yaml
# scheduler-config.yaml
apiVersion: kubescheduler.config.k8s.io/v1
kind: KubeSchedulerConfiguration
profiles:
- schedulerName: aircraft-scheduler
  plugins:
    # 预过滤阶段
    preFilter:
      enabled:
      - name: NodeResourcesFit
      - name: AircraftAvailability

    # 过滤阶段
    filter:
      enabled:
      - name: NodeAffinity
      - name: TaintToleration
      - name: AircraftCapability  # 自定义插件
      - name: FuelCheck           # 自定义插件
      - name: WeaponCompatibility # 自定义插件

    # 评分阶段
    score:
      enabled:
      - name: NodeResourcesBalancedAllocation
        weight: 1
      - name: FuelLevelScore      # 自定义插件
        weight: 3                 # 燃料权重较高
      - name: LocationScore       # 自定义插件
        weight: 2
      - name: MaintenanceScore    # 自定义插件
        weight: 1

    # 绑定阶段
    bind:
      enabled:
      - name: DefaultBinder

  # 插件配置
  pluginConfig:
  - name: FuelLevelScore
    args:
      minimumFuelThreshold: 30  # 最低燃料阈值

  - name: LocationScore
    args:
      adjacentZones:
        east-sea: ["south-sea", "yellow-sea"]
        south-sea: ["east-sea"]
```

### 3.4 调度决策示例

假设有以下飞机节点：

| 节点 | 型号 | 状态 | 油量 | 挂载点 | 位置 | 距离维护 |
|------|------|------|------|--------|------|----------|
| j20-01 | j20 | ready | 95% | 10 | east-sea | 45天 |
| j20-02 | j20 | ready | 80% | 10 | south-sea | 20天 |
| j20-03 | j20 | busy | 90% | 10 | east-sea | 30天 |
| j20-04 | j20 | ready | 60% | 10 | east-sea | 8天 |

任务要求：
- 飞机型号：j20
- 最低油量：70%
- 目标区域：east-sea
- 需要挂载点：6个

**调度过程：**

1. **Filter阶段**（淘汰不符合条件的节点）
   - j20-01: ✅ 通过所有检查
   - j20-02: ✅ 通过所有检查（虽然位置不在east-sea，但燃料充足）
   - j20-03: ❌ 被淘汰（正在执行任务）
   - j20-04: ❌ 被淘汰（燃料60% < 70%）

2. **Score阶段**（为通过的节点打分）

   **j20-01评分：**
   - FuelLevelScore: 95分（权重3） = 285
   - LocationScore: 100分（权重2）= 200（位置完美匹配）
   - MaintenanceScore: 100分（权重1）= 100（距离维护45天）
   - **总分：585**

   **j20-02评分：**
   - FuelLevelScore: 80分（权重3） = 240
   - LocationScore: 70分（权重2）= 140（相邻区域）
   - MaintenanceScore: 70分（权重1）= 70（距离维护20天）
   - **总分：450**

3. **选择结果**：**j20-01** 获胜（总分585 > 450）

## 四、武器版本管理

### 4.1 武器镜像版本策略

```yaml
# 武器版本定义
apiVersion: airforce.mil/v1alpha1
kind: Weapon
metadata:
  name: pl15-missile
spec:
  # 镜像仓库
  image:
    repository: registry.mil/weapons/pl15-missile
    tag: v2.3.0
    pullPolicy: IfNotPresent

  # 版本历史
  versionHistory:
  - version: v2.3.0
    releaseDate: "2024-03-01"
    changelog: |
      - 改进目标识别算法
      - 增强抗干扰能力
      - 修复已知bug
    deprecated: false

  - version: v2.2.0
    releaseDate: "2023-12-01"
    changelog: |
      - 优化制导系统
      - 提升命中率
    deprecated: true
    deprecationDate: "2024-06-01"

  # 更新策略
  updateStrategy:
    type: RollingUpdate     # RollingUpdate, Recreate, HotReload
    rollingUpdate:
      maxUnavailable: 1     # 最多有1个任务使用旧版本
      maxSurge: 1           # 最多可以超出1个新版本实例
```

### 4.2 武器热更新机制

```go
// Weapon Controller监听武器版本变化
type WeaponReconciler struct {
    client.Client
}

func (r *WeaponReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    weapon := &airforcev1alpha1.Weapon{}
    if err := r.Get(ctx, req.NamespacedName, weapon); err != nil {
        return ctrl.Result{}, err
    }

    // 检测镜像版本是否变化
    if weapon.Status.CurrentVersion != weapon.Spec.Image.Tag {
        log.Printf("检测到武器版本变化: %s -> %s",
            weapon.Status.CurrentVersion, weapon.Spec.Image.Tag)

        // 查找所有使用该武器的FlightTask
        tasks := &airforcev1alpha1.FlightTaskList{}
        if err := r.List(ctx, tasks, client.MatchingLabels{
            "weapon": weapon.Name,
        }); err != nil {
            return ctrl.Result{}, err
        }

        // 根据更新策略更新武器
        switch weapon.Spec.UpdateStrategy.Type {
        case "RollingUpdate":
            return r.rollingUpdateWeapon(ctx, weapon, tasks.Items)
        case "Recreate":
            return r.recreateWeapon(ctx, weapon, tasks.Items)
        case "HotReload":
            return r.hotReloadWeapon(ctx, weapon, tasks.Items)
        }
    }

    return ctrl.Result{}, nil
}

// 滚动更新武器
func (r *WeaponReconciler) rollingUpdateWeapon(ctx context.Context, weapon *airforcev1alpha1.Weapon, tasks []airforcev1alpha1.FlightTask) (ctrl.Result, error) {
    // 逐个更新使用该武器的Pod
    for i := range tasks {
        task := &tasks[i]

        // 获取Pod
        pod := &corev1.Pod{}
        if err := r.Get(ctx, client.ObjectKey{
            Name:      task.Status.PodRef.Name,
            Namespace: task.Namespace,
        }, pod); err != nil {
            continue
        }

        // 更新武器Sidecar容器的镜像
        for j := range pod.Spec.Containers {
            if strings.HasPrefix(pod.Spec.Containers[j].Name, "weapon-") {
                pod.Spec.Containers[j].Image = fmt.Sprintf("%s:%s",
                    weapon.Spec.Image.Repository, weapon.Spec.Image.Tag)
            }
        }

        // 删除旧Pod，创建新Pod（K8s会自动使用新镜像）
        r.Delete(ctx, pod)

        // 等待Pod重新创建
        time.Sleep(5 * time.Second)
    }

    // 更新武器状态
    weapon.Status.CurrentVersion = weapon.Spec.Image.Tag
    weapon.Status.LastUpdateTime = metav1.Now()
    return ctrl.Result{}, r.Status().Update(ctx, weapon)
}
```

## 五、性能优化

### 5.1 武器镜像预拉取

```yaml
# 在每个飞机节点上部署DaemonSet，预拉取常用武器镜像
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: weapon-image-preloader
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: weapon-preloader
  template:
    metadata:
      labels:
        app: weapon-preloader
    spec:
      nodeSelector:
        aircraft.mil/type: ""  # 匹配所有飞机节点

      containers:
      - name: preloader
        image: registry.mil/utils/image-preloader:v1.0
        env:
        - name: PRELOAD_IMAGES
          value: |
            registry.mil/weapons/pl15-missile:v2.3.0
            registry.mil/weapons/pl10-missile:v1.8.0
            registry.mil/weapons/pl12-missile:v1.5.0
            registry.mil/weapons/cm400akg:v2.1.0

        command: ["/bin/sh", "-c"]
        args:
        - |
          for image in $PRELOAD_IMAGES; do
            echo "预拉取镜像: $image"
            docker pull $image
          done
          echo "镜像预拉取完成，进入守护模式"
          sleep infinity

        volumeMounts:
        - name: docker-sock
          mountPath: /var/run/docker.sock

      volumes:
      - name: docker-sock
        hostPath:
          path: /var/run/docker.sock
```

### 5.2 武器池（Weapon Pool）

为了加快武器挂载速度，可以预先创建"武器池"Pod：

```yaml
# 武器池StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: weapon-pool-pl15
  namespace: weapons
spec:
  serviceName: weapon-pool
  replicas: 5  # 预创建5个PL-15实例
  selector:
    matchLabels:
      app: weapon-pool
      weapon: pl15
  template:
    metadata:
      labels:
        app: weapon-pool
        weapon: pl15
    spec:
      containers:
      - name: pl15-missile
        image: registry.mil/weapons/pl15-missile:v2.3.0
        ports:
        - containerPort: 9001
        env:
        - name: POOL_MODE
          value: "true"  # 池化模式，待命状态
```

当FlightTask需要武器时，直接从池中"借用"，任务完成后"归还"。

## 六、监控与可观测性

### 6.1 武器状态监控

```yaml
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: weapon-metrics
  namespace: weapons
spec:
  selector:
    matchLabels:
      app: weapon
  endpoints:
  - port: metrics
    interval: 10s
    path: /metrics
```

```go
// 武器系统暴露Prometheus指标
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    weaponLaunchTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "weapon_launch_total",
            Help: "武器发射总次数",
        },
        []string{"weapon_type", "aircraft_type"},
    )

    weaponLaunchSuccess = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "weapon_launch_success_total",
            Help: "武器发射成功次数",
        },
        []string{"weapon_type"},
    )

    weaponTemperature = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "weapon_temperature_celsius",
            Help: "武器系统温度",
        },
        []string{"weapon_type", "mount_point"},
    )

    weaponRemainingCount = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "weapon_remaining_count",
            Help: "武器剩余数量",
        },
        []string{"weapon_type", "aircraft"},
    )
)
```

### 6.2 调度决策追踪

```yaml
# 在Pod的Event中记录调度决策
events:
- type: Normal
  reason: Scheduled
  message: |
    成功调度到节点 j20-01
    调度分析:
      - 候选节点: j20-01, j20-02
      - j20-01评分: 585 (燃料:95, 位置:100, 维护:100)
      - j20-02评分: 450 (燃料:80, 位置:70, 维护:70)
      - 最终选择: j20-01
```

## 七、下一步

下一章将提供**完整的远海打击任务示例**，包括：
- 完整的YAML配置文件
- 任务执行流程演示
- 故障场景和恢复
- 监控数据展示
