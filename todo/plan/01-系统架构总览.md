# 空军体系作战任务K8s平台架构规划

## 一、系统概述

本系统将空军体系作战任务映射到Kubernetes平台，通过Master节点（地面平台）向Node节点（空中平台/飞机）分发任务，实现作战任务的自动化编排、调度和执行。

### 1.1 设计目标

- **任务自动化编排**：地面平台发布任务，系统自动分解、调度到合适的空中平台
- **动态调度**：根据飞机状态（型号、油量、挂载能力、位置等）智能调度任务
- **敏捷部署**：支持任务快速下发、武器动态挂载、能力热更新
- **容错能力**：任务失败自动重试、重新调度，保证任务完成率
- **体系协同**：支持多阶段、多机型、多域协同作战

### 1.2 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Master Node (地面指挥平台)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Mission      │  │ Stage        │  │ FlightTask   │      │
│  │ Controller   │→ │ Controller   │→ │ Controller   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  ┌──────────────────────────────────────────────────┐      │
│  │        API Server (CRD资源管理)                   │      │
│  └──────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓
    ┌───────────────────────┼───────────────────────┐
    ↓                       ↓                       ↓
┌────────┐            ┌────────┐            ┌────────┐
│ Node 1 │            │ Node 2 │            │ Node N │
│ 歼-20  │            │ 轰-6K  │            │空警-500│
│        │            │        │            │        │
│ ┌────┐ │            │ ┌────┐ │            │ ┌────┐ │
│ │Pod │ │            │ │Pod │ │            │ │Pod │ │
│ │任务│ │            │ │任务│ │            │ │任务│ │
│ └────┘ │            │ └────┘ │            │ └────┘ │
└────────┘            └────────┘            └────────┘
```

### 1.3 核心设计理念

1. **任务即资源（Mission as Resource）**
   - 使用CRD定义任务，声明式管理任务生命周期
   - 任务状态通过K8s原生机制追踪和更新

2. **飞机即节点（Aircraft as Node）**
   - 每架飞机作为K8s Node，标注型号、能力、状态
   - 利用K8s调度器实现智能任务分配

3. **武器即能力（Weapon as Capability）**
   - 武器以容器镜像形式存在，动态挂载到任务Pod
   - 支持武器的版本管理、升级和热更新

4. **阶段即工作流（Stage as Workflow）**
   - 任务按阶段分解，阶段间有依赖关系
   - 支持串行、并行、条件执行等复杂流程

## 二、核心概念映射

### 2.1 K8s资源与作战概念映射表

| 作战概念 | K8s资源 | 说明 |
|---------|---------|------|
| 地面指挥平台 | Master Node | 运行控制平面，管理所有资源 |
| 飞机/空中平台 | Worker Node | 执行任务的计算节点 |
| 作战任务 | Mission CRD | 顶层任务对象，包含多个阶段 |
| 任务阶段 | MissionStage CRD | 任务的执行阶段（侦察、压制、打击） |
| 飞行任务 | FlightTask CRD | 单架飞机的具体任务 |
| 任务执行 | Pod | 飞机执行任务的运行实例 |
| 武器装备 | Container Image | 武器系统的容器化封装 |
| 武器挂载 | Sidecar Container | 武器容器附加到任务Pod |
| 飞机能力 | Node Labels | 标注飞机型号、油量、挂载点等 |
| 任务调度 | Scheduler | 根据飞机能力分配任务 |
| 任务监控 | Controller | 监听资源变化，执行控制逻辑 |

### 2.2 示例：远海打击任务映射

以文档中的"远海方向重要目标综合侦察—压制—打击示范行动"为例：

```yaml
Mission: 远海打击任务
├── Stage 1: 侦察与态势建立
│   ├── FlightTask: 空警-500预警指挥
│   ├── FlightTask: 无侦-10前沿侦察
│   └── FlightTask: 歼-20护航
├── Stage 2: 制空掩护与电子压制
│   ├── FlightTask: 歼-20夺取制空
│   ├── FlightTask: 歼-16D电磁压制
│   └── FlightTask: 无侦-10电磁侦搜
└── Stage 3: 远程打击与评估
    ├── FlightTask: 轰-6K远程打击
    ├── FlightTask: 攻击-11隐身穿透
    ├── FlightTask: 无侦-10效果评估
    └── FlightTask: 运油-20A支援保障
```

## 三、关键技术挑战与解决方案

### 3.1 挑战1：武器如何挂载到飞机？

**问题**：用户提出武器作为独立镜像创建Deployment，但回收不好处理

**解决方案**：**Sidecar + Init Container模式**

```yaml
# 不使用独立的Weapon Deployment
# 而是将武器作为Sidecar容器注入到FlightTask Pod中

apiVersion: v1
kind: Pod
metadata:
  name: j20-mission-001
spec:
  # 主容器：飞机飞控系统
  containers:
  - name: aircraft-control
    image: j20-control:v1

  # Sidecar容器：武器系统（PL-15导弹）
  - name: weapon-pl15
    image: weapon-pl15:v2.3
    volumeMounts:
    - name: weapon-interface
      mountPath: /weapon

  # Init Container：武器预加载和检查
  initContainers:
  - name: weapon-preload
    image: weapon-loader:v1
    command: ["sh", "-c", "echo '武器系统初始化完成'"]
```

**优势**：
- ✅ 武器随任务Pod一起创建和销毁，生命周期一致
- ✅ 无需单独管理Weapon Deployment
- ✅ 支持一个Pod挂载多个武器（多个Sidecar）
- ✅ 通过Volume共享武器接口，主容器可以调用武器能力

### 3.2 挑战2：如何判断飞机是否有能力执行任务？

**问题**：需要检查型号、是否在执行任务、油量等多个条件

**解决方案**：**Node Labels + Taints + 自定义调度器**

#### 方案A：使用Node Labels和Affinity（推荐）

```yaml
# 飞机Node的标签
apiVersion: v1
kind: Node
metadata:
  name: j20-001
  labels:
    aircraft.type: j20              # 飞机型号
    aircraft.status: ready          # 状态：ready/busy/maintenance
    aircraft.fuel: high             # 油量：high/medium/low
    aircraft.hardpoint.count: "6"   # 挂载点数量
    aircraft.capability.stealth: "true"  # 隐身能力
    aircraft.location.zone: "east-sea"   # 位置区域
```

```yaml
# FlightTask的Pod模板，使用NodeSelector和Affinity
apiVersion: v1
kind: Pod
spec:
  # 硬性要求：必须是歼-20
  nodeSelector:
    aircraft.type: j20

  # 软性偏好：优先调度到油量高的飞机
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: aircraft.status
            operator: In
            values: ["ready"]  # 必须是就绪状态
          - key: aircraft.fuel
            operator: NotIn
            values: ["low"]    # 油量不能太低
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
          - key: aircraft.fuel
            operator: In
            values: ["high"]   # 优先选择油量高的
```

#### 方案B：自定义Scheduler Plugin

```go
// 自定义调度插件，实现更复杂的调度逻辑
type AircraftSchedulerPlugin struct {}

func (p *AircraftSchedulerPlugin) Filter(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeInfo *framework.NodeInfo) *framework.Status {
    node := nodeInfo.Node()

    // 检查1：飞机型号匹配
    requiredType := pod.Labels["required-aircraft-type"]
    if node.Labels["aircraft.type"] != requiredType {
        return framework.NewStatus(framework.Unschedulable, "aircraft type mismatch")
    }

    // 检查2：是否正在执行任务（通过查询Node上运行的Pod数量）
    if len(nodeInfo.Pods) > 0 {
        return framework.NewStatus(framework.Unschedulable, "aircraft is busy")
    }

    // 检查3：油量是否足够
    fuel := node.Labels["aircraft.fuel"]
    requiredFuel := pod.Annotations["required-fuel-level"]
    if !isFuelSufficient(fuel, requiredFuel) {
        return framework.NewStatus(framework.Unschedulable, "insufficient fuel")
    }

    return framework.NewStatus(framework.Success, "")
}
```

### 3.3 挑战3：任务失败如何重新调度？

**解决方案**：**多层次容错机制**

#### 层次1：Pod级别自动重启
```yaml
apiVersion: v1
kind: Pod
spec:
  restartPolicy: OnFailure  # Pod内容器失败自动重启
```

#### 层次2：FlightTask Controller重新调度
```go
// FlightTask Controller监听Pod状态
func (r *FlightTaskReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    flightTask := &FlightTask{}
    r.Get(ctx, req.NamespacedName, flightTask)

    pod := &v1.Pod{}
    r.Get(ctx, types.NamespacedName{Name: flightTask.Status.PodName}, pod)

    // 检测Pod失败
    if pod.Status.Phase == v1.PodFailed {
        // 标记当前Node为不可用（添加Taint）
        r.taintNode(pod.Spec.NodeName, "task-failed")

        // 删除失败的Pod
        r.Delete(ctx, pod)

        // 重新创建Pod，调度器会自动避开被Taint的Node
        newPod := r.createPodForFlightTask(flightTask)
        r.Create(ctx, newPod)

        // 更新FlightTask状态
        flightTask.Status.RetryCount++
        flightTask.Status.Phase = "Retrying"
        r.Status().Update(ctx, flightTask)
    }

    return ctrl.Result{}, nil
}
```

#### 层次3：Stage Controller阶段重试
```go
// Stage Controller检测整个阶段的健康状态
func (r *StageReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    stage := &MissionStage{}
    r.Get(ctx, req.NamespacedName, stage)

    // 检查阶段内所有FlightTask的状态
    allSuccess := true
    for _, taskName := range stage.Spec.FlightTasks {
        task := &FlightTask{}
        r.Get(ctx, types.NamespacedName{Name: taskName}, task)

        if task.Status.Phase == "Failed" && task.Status.RetryCount >= 3 {
            allSuccess = false
            break
        }
    }

    if !allSuccess {
        // 整个阶段失败，根据策略决定是否重试或终止任务
        if stage.Spec.RetryPolicy == "retry-stage" {
            // 重新创建整个阶段的所有FlightTask
            r.recreateAllFlightTasks(stage)
        } else {
            // 标记任务失败，通知上层Mission Controller
            stage.Status.Phase = "Failed"
            r.Status().Update(ctx, stage)
        }
    }

    return ctrl.Result{}, nil
}
```

### 3.4 挑战4：如何实现动态更新和敏捷部署？

**解决方案**：**分层更新策略**

#### 策略1：武器热更新（秒级）
```yaml
# 更新Weapon CRD的镜像版本
apiVersion: airforce.mil/v1
kind: Weapon
metadata:
  name: pl15-missile
spec:
  image: weapon-pl15:v2.4  # 从v2.3升级到v2.4
  updateStrategy: HotReload
```

```go
// Weapon Controller监听到变化，触发所有使用该武器的Pod更新
func (r *WeaponReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    weapon := &Weapon{}
    r.Get(ctx, req.NamespacedName, weapon)

    // 查找所有使用该武器的Pod
    pods := &v1.PodList{}
    r.List(ctx, pods, client.MatchingLabels{"weapon": weapon.Name})

    for _, pod := range pods.Items {
        // 更新Sidecar容器的镜像（通过删除重建或滚动更新）
        r.updatePodWeaponSidecar(&pod, weapon.Spec.Image)
    }

    return ctrl.Result{}, nil
}
```

#### 策略2：任务动态调整（分钟级）
```yaml
# 用户修改Mission CRD，添加新的阶段或调整流程
apiVersion: airforce.mil/v1
kind: Mission
metadata:
  name: far-sea-strike
spec:
  stages:
  - name: stage1-isr
    phase: Running
  - name: stage2-suppression
    phase: Pending
  - name: stage3-strike
    phase: Pending
  - name: stage4-bda  # 新增：战损评估阶段
    phase: Pending
    tasks:
    - aircraft: wz10
      role: damage-assessment
```

```go
// Mission Controller检测到变化，动态添加新阶段
func (r *MissionReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    mission := &Mission{}
    r.Get(ctx, req.NamespacedName, mission)

    // 对比当前状态和期望状态
    for _, stageSpec := range mission.Spec.Stages {
        stage := &MissionStage{}
        err := r.Get(ctx, types.NamespacedName{Name: stageSpec.Name}, stage)

        if err != nil && errors.IsNotFound(err) {
            // 阶段不存在，创建新阶段
            newStage := r.createStageFromSpec(stageSpec)
            r.Create(ctx, newStage)
        }
    }

    return ctrl.Result{}, nil
}
```

#### 策略3：能力升级（小时级）
```bash
# 通过滚动更新升级飞机控制系统
kubectl set image deployment/j20-control-system \
  aircraft-control=j20-control:v2.0 \
  --record

# 自动逐步替换，不影响正在执行的任务
```

## 四、与用户初步思路的对比

| 方面 | 用户初步思路 | 本方案改进 | 理由 |
|-----|------------|-----------|------|
| 任务表示 | CRD | ✅ 同意，但细化为Mission/Stage/FlightTask三层 | 更好的控制粒度 |
| Controller | 单一Controller | 多个Controller分工协作 | 职责分离，易维护 |
| 任务调度 | Deployment | FlightTask CRD + Pod | CRD更灵活，可扩展 |
| 武器挂载 | 独立Deployment | Sidecar Container | 生命周期一致，易管理 |
| 能力判断 | NodeSelector/Affinity | ✅ 同意 + 自定义Scheduler | 支持复杂调度逻辑 |
| 失败重试 | 调度到其他节点 | ✅ 同意 + 多层次重试 | 更完善的容错 |
| 动态更新 | Deployment滚动更新 | ✅ 同意 + 多层次更新策略 | 不同场景不同策略 |

## 五、后续章节预告

- **02-CRD资源定义详解.md**：详细定义所有CRD的Spec和Status
- **03-Controller实现逻辑.md**：各个Controller的详细实现逻辑
- **04-调度策略设计.md**：自定义调度器和调度策略
- **05-武器管理方案.md**：武器的容器化、挂载和管理
- **06-监控与可观测性.md**：任务监控、日志、指标收集
- **07-部署运维手册.md**：系统部署、配置和运维指南
- **08-示例任务演示.md**：完整的远海打击任务YAML示例
